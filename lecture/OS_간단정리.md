# OS 간단 정리

## chapter02 운영체제 개요
- 운영체제의 역할
  - User Interface
  - Resource management
  - process and thread management
  - system managemneta
- 컴퓨터 시스템의 구성: HW -> reource -> kernel -> system call Interface -> user appilcation
- 운영체제의 구분
  - 사용자의 수 : signle(PC)/multi(server)
  - 동시 실행의 수 : single/multi
  - 작업 수행 방식 : 순차 처리 / batch system / time sharing system / personal computing / parallel processing system / distributed processing system / realTime system
- parellel processing system vs distributed processing system
  - 병렬 처리 --> 단일 시스템 내 둘 이상의 프로세서
  - 분산 처리 --> 여러개의 서버를 두고 처리(네트워크 기반 병렬 처리)
- 운영체제 구조
  - 커널(kernel) : OS의 핵심부분, 가장 빈번하게 사용되는 기능들 담당
  - 유틸리티(utility) : 커널 제외 나머지 부분, UI등 서비스 프로그램
  - 단일 구조 / 계층 구조 / 마이크로 커널 구조 
- 운영체제의 기능은 한마디로 관리! SW/HW 관리. processor, process, memory, File management, I/O Management 등

## chapter03 process management
- Job vs Process
  - Job : program + Data 또는 program 이라고 함
  - Process : 커널에 등록된 작업. 실제 프로그램이 수행되는 주체
  - 프로그램이 메모리에 적재되면 프로세스라고 함
- PCB(Process Control block)
  - 프로세스 생성/관리/제거에 필요한 정보를 모아둔 block
  - 프로세스 생성시 PCB 생성, 커널에 저장됨, OS별로 다름
- 프로세스 상태 : 자원간의 상호작용에 의해 결정
  - create state
    - Job을 커널에 등록한 상태
    - PCB 할당 및 proces 생성, 가용 메모리 공간 여부에 따라 ready 상태, suspended ready 상태로 감
  - ready state
    - CPU 자원 할당을 기다리고 있는 상태, cpu 자원 할당을 받으면 running 상태로 감. 이를 dispatch라고 함
  - Running state 
    - processor 할당 전부 받은 상태. 해당 상태를 벗어나는 경우는 2가지
      - ready  : ready 상태로 바뀌는 것을 preemption 되었다고 함(주로 processor 자원 상태에 따라..)
      - asleep/block : 다른 이벤트 발생(file IO 발생)하여 잠시 딴 일을 해야할 떄
  - blocked/asleep state
    - running 상태에서 잠시 특정한 일이 발생한 상태. 이떄 일이 해결되면 바로 running으로 가는 것이 아니라, ready 상태로 감
  - suspended state
    - process가 메모리를 할당 받지 못한 상태
    - 지금까지 작업한 정보(memory image)를 swap device(일종의 하드 디스크)에 저장
    - memory를 뺏기는 것을 swap out, swap in 이라고 함
  - terminate/zombi state
    - process가 끝난 상태. 모든 자원 반납 후, PCB 정보만 남아 있는 상태
    - 여길 왜 들리는 걸까? 나중에 kernel이 PCB 정보를 수집해 나중에 기억하려고!
  - 인터럽트(interrupt)
    - 예상치 못한, 외부에서 발생한 이벤트
    - 인터럽트 발생시, kernel이 개입해서 해당 프로세스 중단
  - Context -> process와 관련된 정보들의 집합. 크게 두군데 저장됨
  - Context Saving -> 현재 프로세스의 register context를 저장하는 작업
  - Context restoring -> Register context를 프로세스로 복구하는 작업
  - Context switching -> 인터럽트가 발생하여 CPU 점유가 바뀌는 경우 context switching이 발생
  - Context switch overhead -> Context switching에 소요되는 비용


## chapter07 교착상태(deadlock Resolution)
- 교착상태란 어떤 프로세스도 자원을 가져갈 수 없는 상태를 말함
- Blocked/Asleep: 프로세스가 특정 이벤트 때문에 필요한 자원을 기다리는 상태
- deadlock: 프로세스가 발생 가능성이 없는 이벤트를 기다리는 경우  
- deadlock vs starvation
  - deadlock : event가 절대 발생할 수 없음
  - starvation : 운이 나빠 발생을 안함
- 자원의 분류
  - 선점 가능 여부 --> 선점 가능하냐? 
    - preemptible/non-preemptible
  - 할당 단위 --> 쪼갤수 있느냐?
    - Total/Partitioned 
  - 동시 사용 가능 여부 --> shared 가능 여부
    - exclusive/shared 
  - 재사용 여부 --> 쓰고 또 쓰고 가능하냐?
    - serially-reusable/consumable
- 자원의 형태에 따른 deadlock 가능 여부
  - non-preemptible/exclusive..
- Deadlock model
  - Graph-model/State transition model
- <b>deadlock 발생 필요 조건</b>
  - 자원 특성
    - non-preemptible/exclusive use of resources
  - 프로세스 특성
    - hold and wait
    - circular wait    

## chapter 09 가상메모리
- 가상메모리 : non-continuous allocation
- non-continuous allocation
  - 메모리를 여러개의 block 단위로 나눔 
  - 필요한 부분만 메모리에 적재하고, 나머지 block은 swap device에 저장
- non-continuous allocation 기법들
  - paging system 
  - segmentation system
  - Hybrid paging/segmentation system 
- block mapping
  - 간단한 address mapping 
- block mapping 순서
  - virtual v = address(b, d) 
  - process의 BMT(block map table)에 접근
  - BMT에서 block b에 대한 항목(entry) 찾음
  - Residence bit 검사
    - 0 인 경우, 해당 block을 swap device에서 메모리로 가져옴
    - 1 인 경우, 아래 단계 수행
  - BMT에서 read address 값 a 확인
  - 실제 주소 r = a + d 계산
  - r을 이용하여 메모리에 접근   
- paging system
  - 프로그램을 같은 크기의 block 단위로 분할(page)
  - 메모리에서 page 크기에 매핑되는 부분을 page frame이라고 함  
- paging system의 특징
  - 논리적 분할이 아니라, 물리적으로 동일한 크기로 분할
  - No external fragmentation --> page의 크기가 동일
  - Yes internal fragmentation   
- paging system address mapping
  - PMT(Page map table), kernel에 존재 
  - address mapping algorithm
    - Direct mapping
    - Associative mapping
    - Hybrid direct/associative mapping
- Direct mapping 순서
  - 가장 간단한 paging system에서의 address mapping 
  - 해당 프로세스의 PMT가 저장되어 있는 주소 b에 접근
  - 해당 PMT에서 page p에 대한 entry 찾음
    - b(PMT base address) + (p * entrySize)
  - 찾아간 entry의 존재 비트 검사
    - bit가 0이면(page fault), running -> asleep하고, swap device에서 page을 메모리에 적재
    - bit가 1이면 아래 단계 수행
  - entry에서 pagr frame number(p') 확인
  - p'와 가상 주소의 변위 d를 사용하여 실제 주소 r 형성
    - r = p' * pageSize + d
  - 실제 주소 r로 주기억장치에 접근  
- Associate mapping
  - TLB(translation Look-aside Buffer)에 PMT 적재(전용 HW)
  - PMT를 병렬 탐색
- Hybrid Direct/Associative Mapping
  - 두 기법을 혼합하여 사용 
  - Locality를 활용하여 최근에 사용한 page, 근처 page들만 TLB에 저장하고 나머지는 PMT에 저장
- Hybrid Direct/Associative Mapping 순서
  - TLB에 p가 적재되어 있는 경우, residnece bit 검사 후 page frame 확인
  - TLB에 p가 적재되어 있지 않은 경우, PMT에서 page frame 확인
  - 해당 page를 TLB에 적재

## chapter09_2 가상 메모리 관리
- Cost Model for Virtual Mem Sys.
  - Page fault : 메모리에 page가 없는 경우, page fault 발생
  - process가 running -> asleep 상태로 변환되고, 이 때 context switching  발생
- Page reference string(d)
  - 참조한 page들을 문자열로 써 놓은 것
  - 프로세스의 수행 중 참조한 페이지 번호 순서  
- Hardware component
  - Bit vectors: 메모리 상에 page가 가득 찼을 때, 새로운 page를 할당하려고 할 때 활용 
    - reference bit : 해당 page의 참조 여부를 1,0으로 기록한 bit
    - update bit : 갱신 비트 --> page data가 갱신되었는가? 
- reference bit
  - 해당 page의 참조 여부 기록. 
  - 주기적으로 해당 bit를 0으로 초기화 
- update bit
  - Page가 메모리에 적재된 후, 프로세스에 의해 수정되었는지를 표시
  - 프로세스가 page를 변경하면, 데이터 무결성을 위하여 swap-device에도 정보를 알려줘야 함 
- 가상 메모리 성능 향상을 위한 관리 기법들
  - allocation strategies  -> 어떻게 메모리 할당을 할 것인가? 
    - fixed allocation --> 정해진 크기만큼 pf 할당
    - variable allocation --> 동적 크기만큼 pf 할당
  - Fetch strategies       -> 특정 page를 메모리에 언제 적재할 것인가? 
    - demand fetch --> 프로세스가 참조하는 page들만 적재
    - anticipatory fetch --> 가까운 미래에 참조될 가능성이 높은 page를 미리 적재(pre-paging, preFetch등)  
  - placement strategies   -> 어디에 적재할 것인가?
    - paging system에서는 불필요
    - segmentation system --> best/worst/first/next - fit  
  - replacement strategies -> 새로운 page를 어떻게 교체할 것인가? 
    - fixed replacement를 위한 기법
    - variable replacement를 위한 기법
  - clean strategies       -> 변경된 page를 언제 write-back 할 것인가? 
    - demand cleaning : 해당 page에 메모리에서 내려올 때 write-back
    - anticipatory cleaning : 더 이상 변경될 가능성이 없다고 판단 할 때 미리 write-back 
  - load control strategies
    - load : 부하
    - multi-programming degree(수행되는 프로세스 수) 조절  
- thrashing --> 과도한 page fault 현상 발생